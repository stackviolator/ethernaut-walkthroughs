------------------
NOTES
------------------

LEVEL 18: Magic Number
------------------

Challenge - Writing EVM bytecode by hand
- This challenge requires you to respond to a function,
	whatIsTheMeaningOfLife(), and return 42
	- However the catch is that the contract you deploy must be less than or
		equal to 10 opcodes
	- To solve this challenge we will step through making a contract with
		solidity -> solidity inline assembly -> raw EVM assembly -> raw EVM
		opcodes and bytecode

- Solidity is a high level language which gets converted by a compiler into
	binary that the EVM can understand
	- This binary takes shape in the form of bytecode, or a string hexadecimal bytes
- When solidity is compiled, the compiler will often place extra checks and
	features which pads the amount of opcodes and bytes that the final bytecode
	will occupy
- For this challenge we need to explicitly declare the precise instructions
	for the EVM to execute

- Initialization code vs Runtime code
	- When creating a contract, an address will send a string of bytecode to a
		null address, this format of raw bytes to a null address is understood as
		a contract creation
		- The bytecode send has two portions the initialization (init) code and
			the runtime code
			- The init code sets up the contract that will be used and returns the
				runtime bytecode
				- Init code is basically the constructor we defined
				- The general purpose of the init code is to copy the runtime code into
			- The runtime code is the actual logic and functionality within the
				contract. Here is where all the functions are
		- The format of the bytecode is init code followed by the runtime code
			- <init code><runtime code>

- The general process of writing bytecode by hand
	- Create the runtime code
		- Create smart with code
			- Same as the normal process, create a contract with the desired
				functionality
		- Replace code with inline assembly
			- Using the inline assembly feature of solidity, decreasing the amount
				of opcodes placed in by the compiler
		- Use a debugger to find real EVM assembly and convert the assembly to bytecode
			- When a contract is deploy in Remix, you have to options to debug
				transactions
			- Call the function with the desired functionality and select the debug
				function
			- There will be a section where you can review the assembly generated by
				the compiler
			- Each assembly instruction has a specified bytecode value
			- Example:

				PUSH1 FF 		60FF

				- In this exmaple, the PUSH1 instruction has a corresponding bytecode
					of "60" therefore PUSH1 with the argument FF is translated to 60FF

Exploitation
- Source code and comments are found in "/contracts/18_magic_number.sol"
- Note, for debugging and testing, use the Remix VM network in Remix,
	rather than the injected Provider
	- But don't forget to switch back to Injected Provider network when its time
		to solve the challenge :^)
- Creating an original contract that returns 42
	- The original functionality of the program is very easy to follow
	- Create a simple constructor and a function that returns 42 like the
		following

		function whatIsTheMeaningOfLife() public returns (uint) {
			return 42;
		}

	- When compiled and ran this function will successfully return 42, however
		the length of opcodes is wayyyyy too long
	- Analyzing the opcodes
		- This process will be used throughout the challenge and possibly in the
			future
		- To analyze the opcodes a contract must be deployed and a transaction
			sent
			- Same process for this as we have done many times in the past, compile
				and deploy your contract in Remix
			- Call any of the functions from the Remix interface
		- Once the contract is on the blockchain and a transaction has been send,
			there will be a blue button in the output section of the Remix label
			"Debug" this will take you to the debugging panel of Remix
			- Alternatively, the debugging sections can be accessed via the fifth
				icon (of a bug) on left panel
		- From this panel, there is various information, we are primarily
			interested in the disassembly and the step information
		- The step information reveals the amount of opcodes used, we need this
			number to crunch down as small as possible

- Removing some opcodes with inline assembly
	- The first method to having lower level control of a contract is using
		solidity's in line assembly feature

		assembly { <asm code> }

	- We can use this disassembly as a guide and reading the disassembly in
		Remix, however it is not as helpful as just copying everything into
		assembly
	- There are 3 instructions that are primarily interesting to us for now,
		PUSH1, MSTORE and RETURN
		- PUSH1 will push one byte on the stack, MSTORE will store a range of
			bytes on the stack to memory and RETURN will return a range of bytes
	- Solidity inline assembly will take care of operations like PUSH for us, so
		we only need to incorporate MSTORE and RETURN
	- Refer to the following solidity code:

		function whatIsTheMeaningOfLife() public returns (uint) {
    	assembly {
      	mstore(0x00, 0x2A)
      	return(0x0, 0x20)
    	}
		}

		- MSTORE takes in two parameters, of offset of where the data will be
			stored and the bytes you want to store
			- 0x0 	= 	beginning of memory
			- 0x2A 	= 	hex representation of 42
		- RETURN takes two parameters, the the starting offset of the data and he
			length of the data to return
			- 0x0 	= 	beginning of memory, where we stored 42 with mstore
			- 0x20 	= 	 Represents decimal 32, or the first 32 bytes of memory
				(remember slots and how data is stored?)

- Leaving the comfort of Remix and assembling a program by hand
	- If we analyze the opcodes of the in line solidity, we see that we still
		exceed the 10 opcode limit and need to get smaller
	- Thinking back to the 3 instructions that were interesting we can create a
		program with just 10 opcodes that will return 42

		Instructions 	Bytes
		PUSH1 2a    	60 2a 		// 2 bytes
		PUSH1 00    	60 00 		// 2 bytes
		MSTORE      	52 				// 1 byte
		PUSH1 20    	60 20 		// 2 bytes
		PUSH1 00    	60 00 		// 2 bytes
		RETURN      	f3        // 1 bytes
														+ __________
															 10 bytes

		- Each instruction can be translated into an opcode, PUSH1 = 0x60, MSTORE
			= 0x52, RETURN = F3
		- To see all opcode translations, check out this reference:
			https://www.ethervm.io/
		- The bytes in the above code are equivalent to bytecode of a contract
			- meaning that 0x602a6005360206000f3 is valid bytecode to return "42"
		- This code however, is the runtime code for our contract and we need to
			craft our init code
			- Also if you payed close attention, there are only 10 bytes which will
				satisfy this requirement of the challenge

	- A quick quine (a computer program which takes no input and produces a copy
		of its own source code as its only output) is the following

		Instructions 	Bytes
		PUSH 0a     	60 0a
		PUSH ??     	60 ??
		PUSH 00     	60 00
		CODECOPY    	39
		PUSH 0a     	60 0a
		PUSH 00     	60 00
		RETURN      	f3

	- CODECOPY takes in three parameters, the destination offset or where the
		code will be stored, the length of the INIT code (important to note this
		is currently ?? as we do not know the final length of the init code when
		we are writing it ;) and finally the length of the length of the runtime
		code (which we can count to 10 or 0xa in hex)
	- Once the init code is written out, we can count the amount of expected
		bytes to estimate what to fill in ?? with
		- counting, we see 12 bytes which is 0xc in hex, meaning we can replace
			?? with 0xa
	- Our final init byte code is the following: 0x600a600c600039600a6000f3

- Deploying raw bytecode to the blockchain
	- The final byte code is the runtime code concatenated to the init code to
		achieve the following:

		0x600a600c600039600a6000f3602a60005260206000f3

	- In order to deploy this code to the blockchain, we need to send a
		transaction to a null address with the bytecode as the data

		web3.eth.sendTransaction({from: player, data: <bytecode here>}

	- As discussed earlier, this format will be understood as a contract
		creation transaction and you will be able to resolve the address of the
		new contract with a tool such as etherscan.io
	- Set the ethernaut solver to the contract you just deployed and submit the
		instance

		await contract.setSolver(<your address here>)


https://blog.zeppelin.solutions/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737

https://monokh.com/posts/ethereum-contract-creation-bytecode#:~:text=The%20%22runtime%20code%22%20is%20the,to%20be%20stored%20on%20chain.
